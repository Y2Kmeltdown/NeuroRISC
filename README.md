# NeuroRISC GitHub Portfolio

This Github is separated into three main components, The RTL design which is written in verilog and details the physical hardware design that is loaded on the FPGA, The bootloading which details the assembler, programmer and memory initialisation for the processor which is all written in python and finally the assembly which is the code that is executed by NeuroRISC at runtime that simulates a spiking neural network which is written in RISC V assembly code.

## HDL

This section of the code can be found in the HDL directory of the repository. It contains all of the verilog and schematic files used to compile the NeuroRISC processor. All of the work was done on Quartus Prime 18.1 and the design was compiled and run on a Terasic DE10-Nano

### NeuroRISC

The primary core design can be found in the NeuroRisc.bdf and NeuroRisc.v files. This is the file that describes the functional RISC V core that is used to perform the computations. The following files are submodules of this module.

- alu.v
- control_fsm.v
- FivePortMux.v
- imm_gen.v
- instruction_reg.v
- MDU.v
- mem_size.v
- memory_interface.v
- programCounter.v
- registerFile.v
- TwoPortMux.v
- writeback.v

![image here]()

The core is designed to conform to most of the RV32IM specifications excluding CSR instructions which means it can perform all of the base instruction set and the multiply/divide extension of RISC V. The intention of using this design is to provide a small and reprogrammable core that can efficiently emulate a spiking neural network using integer approximation. The design is simple and doesn't deviate from standard design patterns of RISC V cores. More information on the operation of RISC V can be found in the [RISC V Specification](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf).

### Memory and IO Design

To interface the core with the outside world and maintain persistence across cycles the processor needs IO and memory respectively. The design for this uses Harvard architecture or some call modified Von Neumann Architecture where the processor has a separate instruction and data memory. In this design they are separated but are still accessible across the total address space. For simplicity on chip memory is used. In this design it is impossible to read data memory as instructions but it is still possible to read instructions as data. This is achieved by using a two port instruction memory where one port is wired directly to the processor and addressed by the program counter and the other being wired to a memory interface which connects all memory and IO to the processor through data memory. The memory interface takes the address generated by the processor and maps the address to the appropriate memory bank. The instruction memory has a depth of 256 words and a width of 32 bits and the data memory has a depth of 1024 words and a width of 32 bits. To give an example of how the memory interface works if the processor requests data at the address 0 it will receive the very first instruction in instruction memory, and if the processor requests data at the address 256 it will receive the very first word of data in data memory. The IO of the device is very simple for testing purposes and consists of 5 32 bit words which are only used for debugging and to identify that the processor is doing something. These 5 words are accessible via memory mapped IO and are written to and read from the next 5 addresses beyond data memory.

The following files are submodules of NeuroRISC_With_MEM.v

- Memory_Mapper.v
- NeuroRisc.v
- data_memory.v
- instr_mem.v
- IODevice.v

![image here]()

## Bootloader
The supporting software for NeuroRISC consists of a custom built assembler, programmer and memory initialiser.
All of these are written in python. RVassembler.py, RVprogrammer.py and neuronLoader.py can be found in the Assembly directory of the repository.

### RISC V Assembler

The RISC V assembler is designed to convert RISC V assembly code to RISC V binary machine code. To do this the following functions are used in python to interpret the asm file and generate the appropriate machine code.

The assembler implements the argparse library so it can be used completely through command line using the command:

```
python RVassembler.py -b -m path/to/asm
```

The argument `-b` indicates that a raw binary file will be generated with the same name as the input file in the same directory.

The argument `-m` indicates that a memory initialisation file will be generated with the same name as the input file in the same directory.

#### **Functions**

```python
signExtendBinary
binaryString:str, length:int
return newVal
```

The `signExtendBinary` function takes in a string that can only consists of ones and zeros and extends the string by the value of the first character in the string to the input `length`. For example `binaryString = "1100"` and `length = 8` then the function would return `newVal = "11111100"`

```python
hexConvert
value:str
return hexVal
```

The `hexConvert` function

FIGURE OUT WHAT THIS DOES LMAO

```python
getRegisterBinary
stringValue:str
return registerBinary
```

The `getRegisterBinary` function takes a string input of `"x0"` to `"x31"` (which is the common naming convention of the 32 register files in RISC V assembly) and converts the value to a binary value between 0 and 32. The value is zero extended to 5 bits to prepare it to be loaded into a 32 bit binary string of machine code. For example `stringValue = "x13"` then the function would return `registerBinary = "01101"` which is 13 in binary.

```python
generateMachineCode
parsedList:list[str]
return mCodeList
```

The `generateMachineCode` function is the backbone of the assembler. It takes a list of valid assembly lines that have been scrubbed of comments and then loops through each line to identify the type of instruction and then feeds the string into the appropriate instruction conversion function. The function returns a list of binary strings that represent the machine code equivalent of the assembly instruction.

```python
genRTypeInst
parsedList:list[str]
return out
```

The `genRTypeInst` function is used to generate the appropriate machine code out of an R type RISC V assembly instruction. For the format of an R type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['ADD', 'x1', 'x2', 'x0']` The function would return `out = '00000000000000010000000010110011'`

```python
genITypeInst
parsedList:list[str]
return out
```

The `genITypeInst` function is used to generate the appropriate machine code out of an I type RISC V assembly instruction. For the format of an I type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['ADDI', 'x5', 'x0', '1']` The function would return `out = '00000000000100000000001010010011'`

```python
genSTypeInst
parsedList:list[str]
return out
```

The `genSTypeInst` function is used to generate the appropriate machine code out of an S type RISC V assembly instruction. For the format of an S type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['LW', 'x1', '0', 'x0']` The function would return `out = '00000000000000000010000010000011'`

```python
genBTypeInst
parsedList:list[str]
return out
```

The `genBTypeInst` function is used to generate the appropriate machine code out of an B type RISC V assembly instruction. For the format of an B type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['BLT', 'x10', 'x21', '40']` The function would return `out = '00000001010101010101010001100011'`

```python
genUTypeInst
parsedList:list[str]
return out
```

The `genUTypeInst` function is used to generate the appropriate machine code out of an U type RISC V assembly instruction. For the format of an U type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['LUI', 'x1', '200000']` The function would return `out = '00110000110101000000000010110111'`

```python
genJTypeInst
parsedList:list[str]
return out
```

The `genJTypeInst` function is used to generate the appropriate machine code out of an J type RISC V assembly instruction. For the format of an J type instruction refer to image X. The function takes in an assembly instruction that has been separated into a list of its tokens and then generates the binary data based on the data in each token. For example with an input of `parsedList = ['JAL', 'x1', '20']` The function would return `out = '00000000110000000000000011101111'`

```python
genPseudo
parsedList:list[str]
return mCodeList
```

The function `genPseudo` is used to account for edge cases in the RISC V assembly language. Pseudo instructions are generally multiple instructions bundled into a single instruction to make typing the code easier. This function parses the list for matching pseudo instructions and generates the appropriate instructions in order and returns them as a list of 32 bit binary strings.

```python
generateMif
machineCode:list[str], filename:pathlib.Path
```

The function `generateMif` takes a list of binary strings and a file name and generates a memory initialisation file of the binary data that was input. The function used a template mif file and appends the binary data to it then saves it as a new file. This is primarily useful for FPGA development as MIF files can preload a program into memory on FPGA.

```python
generateHex
machineCode:list[str], filename:pathlib.Path
```

The function `generateHex` is used to generate a file of the raw binary data which can be executed directly by a RISC V processor. The file generated from this can be loaded onto the RISC V processor at runtime.

### NeuroRISC Programmer

### NeuroRISC Memory Loader

## Assembly

### Memory address load Routine

### Izhikevich parameter Load Routine

### Memory Pointer initialization Routine

### Spiking neuron load Routine

### IO Read Routine

### Calculation Routine

### Spike Detection Routine

### Reset Neuron Routine

### Spike Emission Routine

### Spike Store Routine

### Change neuron Routine
