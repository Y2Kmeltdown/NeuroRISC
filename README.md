# NeuroRISC GitHub Portfolio

This Github is separated into three main components, The RTL design which is written in verilog and details the physical hardware design that is loaded on the FPGA, The bootloading which details the assembler, programmer and memory initialisation for the processor which is all written in python and finally the assembly which is the code that is executed by NeuroRISC at runtime that simulates a spiking neural network which is written in RISC V assembly code.

## HDL

This section of the code can be found in the HDL directory of the repository. It contains all of the verilog and schematic files used to compile the NeuroRISC processor. All of the work was done on Quartus Prime 18.1 and the design was compiled and run on a Terasic DE10-Nano

### NeuroRISC

The primary core design can be found in the NeuroRisc.bdf and NeuroRisc.v files. This is the file that describes the functional RISC V core that is used to perform the computations. The following files are submodules of this module.

- alu.v
- control_fsm.v
- FivePortMux.v
- imm_gen.v
- instruction_reg.v
- MDU.v
- mem_size.v
- memory_interface.v
- programCounter.v
- registerFile.v
- TwoPortMux.v
- writeback.v

![image here]()

The core is designed to conform to most of the RV32IM specifications excluding CSR instructions which means it can perform all of the base instruction set and the multiply/divide extension of RISC V. The intention of using this design is to provide a small and reprogrammable core that can efficiently emulate a spiking neural network using integer approximation. The design is simple and doesn't deviate from standard design patterns of RISC V cores. More information on the operation of RISC V can be found in the [RISC V Specification](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf).

### Memory and IO Design

To interface the core with the outside world and maintain persistence across cycles the processor needs IO and memory respectively. The design for this uses Harvard architecture or some call modified Von Neumann Architecture where the processor has a separate instruction and data memory. In this design they are separated but are still accessible across the total address space. For simplicity on chip memory is used. In this design it is impossible to read data memory as instructions but it is still possible to read instructions as data. This is achieved by using a two port instruction memory where one port is wired directly to the processor and addressed by the program counter and the other being wired to a memory interface which connects all memory and IO to the processor through data memory. The memory interface takes the address generated by the processor and maps the address to the appropriate memory bank. The instruction memory has a depth of 256 words and a width of 32 bits and the data memory has a depth of 1024 words and a width of 32 bits. To give an example of how the memory interface works if the processor requests data at the address 0 it will receive the very first instruction in instruction memory, and if the processor requests data at the address 256 it will receive the very first word of data in data memory. The IO of the device is very simple for testing purposes and consists of 5 32 bit words which are only used for debugging and to identify that the processor is doing something. These 5 words are accessible via memory mapped IO and are written to and read from the next 5 addresses beyond data memory.

## Bootloader
The supporting software for NeuroRISC consists of a custom built assembler, programmer and memory initialiser.
All of these are written in python. RVassembler.py, RVprogrammer.py and neuronLoader.py can be found in the Assembly directory of the repository.

### RISC V Assembler

The RISC V assembler is designed to convert RISC V assembly code to RISC V binary machine code. To do this the following functions are used in python to interpret the asm file and generate the appropriate machine code.

The assembler implements the argparse library so it can be used completely through command line using the command:

```
python RVassembler.py -b -m path/to/asm
```

The argument `-b` indicates that a raw binary file will be generated with the same name as the input file in the same directory.

The argument `-m` indicates that a memory initialisation file will be generated with the same name as the input file in the same directory.

#### Functions

```python
signExtendBinary
binaryString:str, length:int
return newVal
```

The `signExtendBinary` function takes in a string that can only consists of ones and zeros and extends the string by the value of the first character in the string to the input `length`. For example `binaryString = "1100"` and `length = 8` then the function would return `newVal = "11111100"`

```python
hexConvert
value:str
return hexVal
```

The `hexConvert` function

```python
getRegisterBinary
stringValue:str
return registerBinary
```

```python
generateMachineCode
parsedList:list[str]
return mCodeList
```

```python
genRTypeInst
parsedList:list[str]
return out
```

```python
genITypeInst
parsedList:list[str]
return out
```

```python
genSTypeInst
parsedList:list[str]
return out
```

```python
genBTypeInst
parsedList:list[str]
return out
```

```python
genUTypeInst
parsedList:list[str]
return out
```

```python
genJTypeInst
parsedList:list[str]
return out
```

```python
genPseudo
parsedList:list[str]
return mCodeList
```

```python
generateMif
machineCode:list[str], filename:pathlib.Path
```

```python
generateHex
machineCode:list[str], filename:pathlib.Path
```

### NeuroRISC Programmer

### NeuroRISC Memory Loader

## Assembly

### Memory address load Routine

### Izhikevich parameter Load Routine

### Memory Pointer initialization Routine

### Spiking neuron load Routine

### IO Read Routine

### Calculation Routine

### Spike Detection Routine

### Reset Neuron Routine

### Spike Emission Routine

### Spike Store Routine

### Change neuron Routine
